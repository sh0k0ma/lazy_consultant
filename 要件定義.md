ハイレベルなコンサルタントとしてWork EthicとCompetencyを高めるために下記のようなデスクトップアプケーションを検討している。
# コンセプト
- タスクをプロジェクト管理するが、タスクはハイレベルなコンサルタントとしてフレームワークに基づいて対応する。
- タスクの種類に応じて検討するべき観点や事項をフェーズごと記載する。
- これにより、インプットおよびアウトプットの抜け漏れを防止するだけでなく、ハイレベルなコンサルタントとして必要な視点や考えを反映させる。
- その結果、早い段階からリスクの洗い出しによる対応、および解像度の高いアウトプットを出せるようにすることが目的である。
# システムデザイン
- Header、Body、Footerの構成になっている
## Header
- 左から順に「Lazy Consultant、「Projects」、「Knowledge」がある。
- 「Lazy Consultant」をクリックするとDashboadを表示する
- 「Projects」をクリックするとドロップダウンになっている。
### Projects
- ドロップダウンで「Projects」をクリックするとプロジェクト一覧だけのページに遷移する。
### Work
- ドロップダウンで「Work」をクリックするとワーク一覧だけのページに遷移する。
### Task
- ドロップダウンで「Task」をクリックするとタスク一覧だけのページに遷移する。
### Knowledge
- Headerで「Knowledge」をクリックするとナレッジのページを新規ページで表示する。

## Body
### Projects
- アプリケーションが起動したらプロジェクトに紐付くワーク一覧とそのワークに紐づくタスク一覧がある（これがDashboard）。
- プロジェクト、タスク、ワークは非表示・表示することができる。
- プロジェクト、タスク、ワークは削除・追加することができる。
	- 削除する際は注意書きが出る。
	- 追加する際はModalで必要な情報を追加できる。
#### Projects追加
- 下記を記載する
	- プロジェクト名
	- プロジェクト概要
	- プロジェクトステータス(Planned, Ongoing, Complete, Blocked, Abandon)
	- 開始日
	- 終了日
#### Work追加
- 下記を記載する。「ジャーナル」とは何は後述。
	- ワーク名
	- ワークの目的
	- 関係者
	- 開始日
	- 終了日
	- ワークステータス(Planned, Ongoing, Complete, Blocked, Abandon)
	- 最初のジャーナル記載事項と日付
#### Task追加
- 下記を記載する。「ジャーナル」とは何は後述。
	- タスク名
	- タスクの目的
	- 関係者
	- 開始日
	- 終了日
	- タスクステータス(Planned, Ongoing, Complete, Blocked, Abandon)
	- 最初のジャーナル記載事項と日付
#### ジャーナルとは
- ワークとタスクで状況を時系列で記載するためのモジュール。目的は今までのやり取りや会話の内容を記録し、仕事の状況を正しく理解するためにある。
- ジャーナルは最新から最古の順で積み上がっていく。
#### Project詳細
- DashboardからProjectをクリックすると詳細を確認できる。
- Project詳細ページには下記が記載されている。
	- プロジェクト名
	- プロジェクトの概要
	- 開始日
	- 終了日
	- プロジェクトステータス(Planned, Ongoing, Complete, Blocked, Abandon)
	- 紐づいているワークの一覧
#### Work詳細
- DashboardからWorkをクリックすると詳細を確認できる。
- Work詳細ページには下記が記載されている。
	- ワーク名
	- ワークの目的
	- 関係者
	- 開始日
	- 終了日
	- ワークステータス(Planned, Ongoing, Complete, Blocked, Abandon)
	- 最後のジャーナルの記載事項と日付
	 - 詳細をクリックすると今までのジャーナルをModalで確認できる。
	- 紐づいているタスクの一覧
#### Task詳細
- DashboardからTaskをクリックすると詳細を確認できる。
- Task詳細ページには下記が記載されている。
	- タスク名
	- タスクの目的
	- タスクのタイプ
	- 関係者
	- 開始日
	- 終了日
	- タスクステータス(Planned, Ongoing, Complete, Blocked, Abandon)
	- 最後のジャーナルの記載事項と日付
	 - 詳細をクリックすると今までのジャーナルをModalで確認できる。
	- 毎日やタスクの場合、"Ongoing"である限り、取り組んだ日付を追加できるボタンがあり、追加された日付にチェックをつけることができる。
	- タスクタイプに応じたタスクフェーズにおける検討状況
#### タスクタイプに応じたタスクフェーズにおける検討状況
> これが本アプリケーションのキーとなる機能
- 下記がタスクタイプであり、タスクのタイプに応じてフェーズごとの項目が表示され、それ記載ができる。
- 各フェーズのページにCompleteボタンを押すと次のフェーズに行ける。
##### 課題定義・論点設計
- 依頼の真意と意思決定ポイントを定義し、Top論点とスコープ（In/Out）を合意したブリーフに落とす。
###### Input（仕事を受けたとき）
- 依頼者の名前を確認する。
- 最終決裁者（最後に決める人）を確認する。
- 目的（何のためか）を一文で書く。
- 期待する成果物の形（例：1枚サマリ、スライド10枚）を確認する。
- 期限（日付と時刻）を確認する。
- 評価軸（何で良し悪しを決めるか）を1行で書く。
- 制約（使えるお金・人・時間・データ）を一覧にする。
- 関係者（影響がある人）をリスト化する。
- 用語の意味を合わせる（例：「売上」「顧客」などを定義する）。
- 過去に同じことをやっていないかを聞く。
- 既にある資料を集める。
- 想定外に起きやすいことを3つ書き出す。

###### Progress（取りかかっているとき）
- 大きな問い（Top論点）を仮に決めて書く。
- スコープの「入れる」「入れない」を別々に書く。
- 大きな問いを小さな問いに分けて一覧にする。
- 各問いに必要な事実（数字・根拠）を書く。
- 先に仮説（こうだと思う）を1行で書く。
- 仮説を確かめるための当て先（データ・人）を決める。
- 前提（こういう条件の上で成り立つ）を表に書く。
- リスク（失敗のもと）を表に書く。
- Issue（今困っていること）を表に書く。
- Decision（決めたこと）を表に書く。
- 1枚のラフ構成（結論→根拠→次アクション）を描く。
- 依頼者に途中の考えを5分で共有する。

###### Output（仕上げたとき）
- ブリーフ（目的・Top論点・スコープ・前提・期限）を1枚にまとめる。
- 判断に必要な事実リストを1枚にまとめる。
- 次にやること（誰が・いつまでに）を表にする。
- 不確実な点（まだ決まっていない点）を一言で書く。

##### リサーチ（市場・競合・技術）
- 意思決定に必要な外部知を収集・要約し、前提と示唆を明文化したファクトパックを作る。
###### Input
- 何を決めるための調査かを一文で書く。
- 必要な出所（公的統計・IR・記事・論文・有識者）を並べる。
- いつの情報が必要か（最新・直近1年など）を書く。
- 比較軸（例：価格・機能・品質・導入のしやすさ）を決める。
###### Progress
- 情報の出所と日付を必ずメモする。
- 事実と意見を分けてメモする。
- 同じ定義で数字をそろえる。
- 競合を同じ表で横並び比較する。
- 気づき（示唆）を各ページに1行で書く。
- 情報の穴（まだない情報）をメモする。
- 穴を埋める方法（追加調査・インタビュー）を書き足す。
###### Output
- 必要最小限のファクト（表・グラフ）だけをまとめる。
- 各ファクトの意味（So What）を1行で書く。
- 次のアクション（誰が・何を・いつ）を最後に書く。

##### データ分析・モデル化
- 主要指標と前提を定義し、事実関係と影響度を定量化した分析・試算モデルを提示する。
###### Input
- 目的の数字（KPI）を一つ決めて書く。
- 期間（例：2024年1月〜3月）を決めて書く。
- データの在りか（ファイル・DB・担当者）を確認する。
- データ品質（抜け・重複・更新頻度）を点検する。
- 使う分析の型（集計・回帰・シミュレーション）を決める。

###### Progress
- 前処理の手順を手順書に書く。
- 計算の式をメモに残す。
- 途中結果をグラフで確認する。
- 感度分析（前提を±で動かす）を実行する。
- 想定外の値をチェックする。
- 前提の変更が結論に与える影響を書き出す。
- 結果の限界（ここまでは言える・ここからは言えない）を言葉にする。

###### Output
- 前提一覧表を1枚にまとめる。
- 計算フロー図を1枚に描く。
- シナリオ別の結果表を1枚にまとめる。
- 決めに使う数字だけをラスト1枚に載せる。
- 補足の細かい分析は付録に分ける。

##### 戦略・施策設計（新規施策を含む）
- 目標に対する選択肢を設計し、トレードオフと優先順位を示した推奨案をまとめる。
###### Input
- 目標（何を達成するか）を1行で書く。
- 評価軸（効果・実現性・費用・スピード・リスク）を並べる。
- 使える資源（人・お金・データ・設備）を書き出す。
- 触ってはいけない範囲（不可侵領域）を書き出す。

###### Progress
- 施策の案を数多く出す（質より量で出す）。
- 案を評価軸で点数づけする。
- 上位の案を3つに絞る。
- 各案の良い点・悪い点を書き分ける。
- 推奨案を1つに決める。
- その理由を3行で書く。
- 30日・60日・90日の実行ステップを書く。
- つまずきやすい点を先に書く。
- つまずき対策（回避策）をセットで書く。

###### Output
- 推奨案の1枚サマリを作る。
- 比較表（捨てた案と残した案）を作る。
- 実行ロードマップ（いつ・誰が・何を）を作る。

##### 実行計画・PMO（プロジェクト運営）
- 達成に必要なWBS・役割・マイルストーン・RAIDを整え、運営カデンスまで含む実行台帳を作る。
###### Input
- 成果物（できあがりの姿）を一文で書く。
- 受け入れ条件（完了の定義）を箇条書きにする。
- マイルストーン（重要な日付）を決める。
- WBS（作業の分解表）を作る。
- RACI（実行・責任・相談・報告の役割）を決める。
- 会議の頻度（全体会・課題会・決裁会）を決める。

###### Progress
- RAID（リスク・前提・問題・決定）を表で更新する。
- スコープ変更の受付方法を書く。
- 変更の影響（工数・費用・日程）を見積もる。
- 変更の承認者を明確にする。
- 進捗の見える化（計画対実績）を週次で更新する。
- 重要な遅れを早めにエスカレーションする。
- ナレッジ（学び）を都度メモする。

###### Output
- 実行台帳（WBS・クリティカルパス・RAID）を配布する。
- 定例会レポート（進捗・課題・次アクション）を出す。
- 次四半期の計画案を提示する。

##### チェンジマネジメント（人の行動を変える）
- 利害関係者の動機・懸念を設計し、教育・周知・運用ルールで行動変容を定着させる。
###### Input
- 関係者を「影響力×関心」でマップ化する。
- 各関係者の「得」になる点を書く。
- 各関係者の不安点を書く。
- 望ましい行動（誰が・いつ・何をする）を書く。

###### Progress
- メッセージ（なぜ・自分の得・やり方）を作る。
- 伝える人（スポークスパーソン）を決める。
- 研修の内容と日程を作る。
- 最初の成功事例を作る。
- 反発の声を集めて記録する。
- 是正の手順（聞く→合意→ルール反映）を実施する。

###### Output
- コミュニケーション計画を発行する。
- 教育計画を発行する。
- 運用ルールを発行する。
- 定着KPI（利用率・満足度）を設定する。

##### 意思決定設計・ガバナンス
- 決定基準・承認フロー・ルール/監査を設計し、合意形成と逸脱時の是正を仕組み化する。
###### Input
- 決める領域ごとに権限を決める。
- 判断基準（OKの幅）を書く。
- 例外の扱い方を書く。
- 監査に必要な記録（ログ・証跡）を決める。

###### Progress
- 提出物のテンプレートを作る。
- 審議の時間配分を決める。
- 逸脱を見つける方法を書き出す。
- 逸脱時の手順（検知→一次対応→恒久対策）を運用する。
- 規程の見直し時期を決める。

###### Output
- ガバナンス文書（基準・フロー・監査）を発行する。
- 運用ダッシュボード（遵守率・例外件数）を公開する。

##### 成果検証・レビュー
- 期待効果と実績を比較し、学び・再設計・撤退/継続判断をドキュメント化する。
###### Input
- 期待値（目標値・期間・計算式）を書く。
- 取得方法（誰が・いつ・どこから）を書く。
- やめる基準（撤退条件）を書く。
###### Progress
- 実績値を同じ定義で集計する。
- 外部要因（季節・他施策）を書き出す。
- 代わりの説明（他の理由）を考えて書く。
- 学び（効いた点・効かなかった点）を3行で書く。
###### Output
- 期待と実績の比較表を作る。
- 継続・縮小・停止の判断を書いて提出する。
- 次の改善案と期限を書いて提出する。

##### ナレッジ化・横展開
- 再利用可能なテンプレート/チェックリスト/ケースを整備し、組織標準として配布する。
###### Input
- 再利用できる資料を選ぶ。
- メタ情報（対象・条件・注意点）を付ける。
- 保管場所と名前の付け方を決める。
###### Progress
- 1枚サマリを作る。
- 使い方の説明を1ページ作る。
- よくある失敗を3点書く。
- レビュー担当と更新頻度を決める。
- 展開先の優先度を書き出す。
- 導入支援（トレーニング・伴走）の手順を書く。
###### Output
- 標準パック（テンプレ・チェックリスト・事例・FAQ）を公開する。
- 利用状況（閲覧・複製・成果への寄与）を記録する。

### Knowledge
- ナレッジサイトである
- 表形式である。
	- フィルタリング可能。
- プロジェクト単位で大項目、小項目で整理され、ナレッジページにはタイトルと詳細を書ける。
- ナレッジページにはタグ付けをすることが可能。

## Footer
- Privacy Policy(今は空で良い)
- 利用規約(今は空で良い)

# システム要件
- HTML、CSS、Java Script、Node.js、jsonで作成すること
- **外部ライブラリ**を絶対に使用しないこと
- 軽量で高速を目指しているので、コードの量は最小限であること
	- デザインより機能性を最優先すること
- アプリケーションはwebであるが、ページを閉じる前に自動保存してから閉じること
- データはjsonかtextで保存し、データベースを利用しないこと
- **WebAPI***は絶対に利用しないこと
## イニシャルの実行
### ディレクトリ構成（推奨）

lazy_consultant/
├─ package.json
├─ .gitignore
├─ src/
│  ├─ server/
│  │  ├─ index.js          # エントリ。Express起動
│  │  ├─ routes/
│  │  │  └─ api.js         # /api のルート定義
│  │  └─ controllers/
│  │     └─ itemsController.js  # APIハンドラの中身
│  └─ data/
│     └─ items.json        # ダミーデータ
└─ public/
   ├─ index.html           # フロント入口
   └─ assets/
      ├─ css/
      │  └─ style.css
      └─ js/
         ├─ main.js       # 画面初期化
         └─ modules/
            ├─ api.js     # fetchラッパ
            └─ dom.js     # DOM操作ユーティリティ

2) package.json

{
  "name": "my-first-webapp",
  "version": "0.1.0",
  "type": "module",
  "private": true,
  "scripts": {
    "dev": "nodemon src/server/index.js",
    "start": "node src/server/index.js"
  },
  "dependencies": {
    "express": "^4.19.2",
    "morgan": "^1.10.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5"
  },
  "devDependencies": {
    "nodemon": "^3.1.0"
  }
}

.gitignore（最小）

node_modules
.env

3) サーバー実装

src/server/index.js

import express from "express";
import morgan from "morgan";
import cors from "cors";
import path from "node:path";
import { fileURLToPath } from "node:url";
import apiRouter from "./routes/api.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3001;

app.use(cors());
app.use(morgan("dev"));
app.use(express.json());

// 静的ファイル配信（public）
app.use(express.static(path.join(__dirname, "../../public")));

// API ルート
app.use("/api", apiRouter);

// ルート直叩きは index.html
app.get("/", (_, res) => {
  res.sendFile(path.join(__dirname, "../../public/index.html"));
});

app.listen(PORT, () => {
  console.log(`✅ Server running: http://127.0.0.1:${PORT}`);
});

src/server/routes/api.js

import { Router } from "express";
import { listItems } from "../controllers/itemsController.js";

const router = Router();

router.get("/health", (_, res) => {
  res.json({ ok: true, service: "my-first-webapp", time: new Date().toISOString() });
});

router.get("/items", listItems);

export default router;

src/server/controllers/itemsController.js

import path from "node:path";
import { fileURLToPath } from "node:url";
import fs from "node:fs/promises";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export async function listItems(req, res) {
  try {
    const dataPath = path.join(__dirname, "../../data/items.json");
    const raw = await fs.readFile(dataPath, "utf-8");
    const items = JSON.parse(raw);
    res.json({ items });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "failed_to_load_items" });
  }
}

src/data/items.json

[
  { "id": 1, "name": "First Item" },
  { "id": 2, "name": "Second Item" }
]

4) フロント（HTML / CSS / JS）

public/index.html

<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>My First Web App</title>
    <link rel="stylesheet" href="/assets/css/style.css" />
  </head>
  <body>
    <header>
      <h1>My First Web App</h1>
    </header>

    <main>
      <section id="health" class="card">
        <h2>Health Check</h2>
        <pre id="health-json">Loading...</pre>
      </section>

      <section id="items" class="card">
        <h2>Items (from /api/items)</h2>
        <ul id="items-list"></ul>
      </section>
    </main>

    <script type="module" src="/assets/js/main.js"></script>
  </body>
</html>

public/assets/css/style.css

:root { --fg: #222; --bg: #fafafa; --card: #fff; --border: #e5e5e5; }
* { box-sizing: border-box; }
html, body { margin: 0; padding: 0; background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
header { padding: 16px 24px; border-bottom: 1px solid var(--border); background: var(--card); position: sticky; top: 0; }
main { max-width: 880px; margin: 24px auto; padding: 0 16px; display: grid; gap: 16px; }
.card { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 16px; }
h1, h2 { margin: 0 0 12px; }
pre { white-space: pre-wrap; word-break: break-word; background: #f4f4f4; border-radius: 8px; padding: 8px; }
ul { margin: 0; padding-left: 18px; }

public/assets/js/modules/api.js

const base = "";

export async function getJSON(pathname) {
  const url = `${base}${pathname}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Request failed: ${res.status}`);
  return res.json();
}

public/assets/js/modules/dom.js

export function el(tag, props = {}, ...children) {
  const node = document.createElement(tag);
  Object.entries(props).forEach(([k, v]) => {
    if (k.startsWith("on") && typeof v === "function") node.addEventListener(k.slice(2), v);
    else if (k === "class") node.className = v;
    else node.setAttribute(k, v);
  });
  children.flat().forEach((c) => node.append(c?.nodeType ? c : String(c)));
  return node;
}

export function clear(node) {
  while (node.firstChild) node.removeChild(node.firstChild);
}

public/assets/js/main.js

import { getJSON } from "./modules/api.js";
import { el, clear } from "./modules/dom.js";

async function boot() {
  // Health
  const healthBox = document.getElementById("health-json");
  try {
    const health = await getJSON("/api/health");
    healthBox.textContent = JSON.stringify(health, null, 2);
  } catch (e) {
    healthBox.textContent = `Error: ${e.message}`;
  }

  // Items
  const list = document.getElementById("items-list");
  clear(list);
  try {
    const data = await getJSON("/api/items");
    data.items.forEach((it) => {
      list.append(el("li", {}, `${it.id}: ${it.name}`));
    });
  } catch (e) {
    list.append(el("li", {}, `Error: ${e.message}`));
  }
}

window.addEventListener("DOMContentLoaded", boot);

5) セットアップ & 起動

# 1. プロジェクト作成
npm init -y

# 2. 依存パッケージ
npm i express morgan cors dotenv
npm i -D nodemon

# 3. 上記ファイルを配置（フォルダとファイルを作成）
# 4. 開発起動（ホットリロード）
npm run dev
# 本番起動
# npm start

# ブラウザ
# http://127.0.0.1:3001/
# API動作確認
# http://127.0.0.1:3001/api/health
# http://127.0.0.1:3001/api/items